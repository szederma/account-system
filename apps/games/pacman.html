<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pac-Man</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            overflow: hidden;
        }
        .game-container-pacman {
            background-color: #2d3748;
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.1);
            text-align: center;
        }
        #gameCanvasPacman {
            border: 3px solid #4a5568;
            background-color: #000000; /* Black game background */
            border-radius: 0.5rem;
            display: block;
            margin: 0 auto;
            touch-action: none; /* For swipe controls */
        }
        .info-pacman {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            width: 100%;
            max-width: 400px; /* Match typical canvas width */
        }
        .score-pacman, .lives-pacman {
            font-size: 1.1rem;
            font-weight: bold;
            color: #90cdf4;
            background-color: #4a5568;
            padding: 0.3rem 0.8rem;
            border-radius: 0.3rem;
        }
        .controls-pacman {
            margin-top: 0.5rem;
        }
        .btn-pacman {
            background-color: #4299e1; color: white; font-weight: 600;
            padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer;
            transition: background-color 0.2s ease; border: none; margin: 0.25rem;
        }
        .btn-pacman:hover { background-color: #3182ce; }
        .btn-back-pacman { background-color: #718096; }
        .btn-back-pacman:hover { background-color: #4a5568; }

        /* Modal */
        .modal-pacman {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            align-items: center; justify-content: center;
        }
        .modal-content-pacman {
            background-color: #2d3748; padding: 25px; border-radius: 0.75rem;
            width: 90%; max-width: 380px; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .modal-title-pacman { font-size: 1.8rem; font-weight: bold; color: #90cdf4; margin-bottom: 1rem; }
        .modal-text-pacman { font-size: 1rem; margin-bottom: 1.5rem; }
        
        /* Touch Controls (Simplified for Pacman - swipes are primary) */
        .touch-info-pacman {
            display: none; /* Shown if touch device */
            color: #a0aec0;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="game-container-pacman">
        <h1 class="text-3xl sm:text-4xl font-bold mb-2 text-center text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500">Pac-Man</h1>
        <div class="info-pacman">
            <div id="scorePacman" class="score-pacman">Score: 0</div>
            <div id="livesPacman" class="lives-pacman">Lives: 3</div>
        </div>
        <canvas id="gameCanvasPacman"></canvas>
        <div class="controls-pacman">
            <button id="startButtonPacman" class="btn-pacman">Start Game</button>
            <button onclick="window.location.href='index.html'" class="btn-pacman btn-back-pacman">Back to Hub</button>
        </div>
        <p id="touchInfoPacman" class="touch-info-pacman">Swipe on game area to move.</p>
    </div>

    <div id="gameModalPacman" class="modal-pacman">
        <div class="modal-content-pacman">
            <h2 id="modalTitlePacman" class="modal-title-pacman">Get Ready!</h2>
            <p id="modalTextPacman" class="modal-text-pacman">Use arrow keys or swipe to move.</p>
            <p id="modalScoreInfoPacman" class="modal-text-pacman" style="display:none;">Score: <span id="modalCurrentScorePacman">0</span></p>
            <button id="modalButtonPacman" class="btn-pacman">Start</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvasPacman');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scorePacman');
        const livesDisplay = document.getElementById('livesPacman');
        const startButton = document.getElementById('startButtonPacman');
        const touchInfoElement = document.getElementById('touchInfoPacman');

        const gameModal = document.getElementById('gameModalPacman');
        const modalTitle = document.getElementById('modalTitlePacman');
        const modalText = document.getElementById('modalTextPacman');
        const modalScoreInfo = document.getElementById('modalScoreInfoPacman');
        const modalCurrentScore = document.getElementById('modalCurrentScorePacman');
        const modalButton = document.getElementById('modalButtonPacman');

        const TILE_SIZE = 20; // Size of each grid cell
        const MAZE_COLS = 19; // Must be odd for symmetry
        const MAZE_ROWS = 21; // Must be odd

        canvas.width = MAZE_COLS * TILE_SIZE;
        canvas.height = MAZE_ROWS * TILE_SIZE;

        // Maze: 0 = empty, 1 = wall, 2 = pellet, 3 = power pellet, 4 = ghost spawn (no pellet)
        // Simplified maze for now
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,3,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1], // Ghost box area (0 = empty path)
            [0,0,0,1,2,1,0,0,0,4,0,0,0,1,2,1,0,0,0], // Tunnel & Ghost box center (4)
            [1,1,1,1,2,1,0,1,1,4,1,1,0,1,2,1,1,1,1],
            [2,2,2,2,2,2,2,1,4,4,4,1,2,2,2,2,2,2,2], // Pacman start row
            [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
            [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0], // Tunnel
            [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];
        let totalPellets = 0;

        let pacman = { x: 0, y: 0, dx: 0, dy: 0, openRate: 0, openDir: 1, radius: TILE_SIZE / 2 - 2 };
        let ghosts = [];
        const GHOST_COLORS = ['#FF0000', '#FFB8FF', '#00FFFF', '#FFB852']; // Blinky, Pinky, Inky, Clyde
        
        let score, lives, gameActive, powerPelletTimer;
        const POWER_PELLET_DURATION = 8000; // 8 seconds
        let gameLoopTimeout;

        function initializeGameVariables() {
            score = 0;
            lives = 3;
            powerPelletTimer = 0;
            pacman.x = Math.floor(MAZE_COLS / 2) * TILE_SIZE + TILE_SIZE / 2;
            pacman.y = 10 * TILE_SIZE + TILE_SIZE / 2; // Specific start row
            pacman.dx = 0; pacman.dy = 0;
            updateInfoDisplays();
            initializeGhosts();
            countPellets();
        }
        
        function countPellets() {
            totalPellets = 0;
            for (let r = 0; r < MAZE_ROWS; r++) {
                for (let c = 0; c < MAZE_COLS; c++) {
                    if (maze[r][c] === 2 || maze[r][c] === 3) {
                        totalPellets++;
                    }
                }
            }
        }

        function initializeGhosts() {
            ghosts = [];
            const spawnPoints = [
                { r: 8, c: 9 }, { r: 9, c: 8 }, { r: 9, c: 10 }, { r: 10, c: 9 } // Around ghost box center
            ];
            for (let i = 0; i < 4; i++) {
                ghosts.push({
                    x: spawnPoints[i].c * TILE_SIZE + TILE_SIZE / 2,
                    y: spawnPoints[i].r * TILE_SIZE + TILE_SIZE / 2,
                    dx: 0, dy: 0,
                    color: GHOST_COLORS[i],
                    isFrightened: false,
                    radius: TILE_SIZE / 2 - 2,
                    targetX: pacman.x, // Initial target
                    targetY: pacman.y,
                    id: i
                });
            }
        }
        
        function resetLevel() { // Called when Pacman loses a life
            pacman.x = Math.floor(MAZE_COLS / 2) * TILE_SIZE + TILE_SIZE / 2;
            pacman.y = 10 * TILE_SIZE + TILE_SIZE / 2;
            pacman.dx = 0; pacman.dy = 0;
            initializeGhosts(); // Reset ghost positions
            powerPelletTimer = 0; // Reset power pellet effect
            ghosts.forEach(g => g.isFrightened = false);
            showModal("Get Ready!", `Lives: ${lives}`, "Continue", startGameLoop);
        }

        function updateInfoDisplays() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Lives: ${lives}`;
        }

        function drawMaze() {
            for (let r = 0; r < MAZE_ROWS; r++) {
                for (let c = 0; c < MAZE_COLS; c++) {
                    ctx.fillStyle = '#000000'; // Default background
                    ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    if (maze[r][c] === 1) { // Wall
                        ctx.fillStyle = '#0033CC'; // Dark blue walls
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else if (maze[r][c] === 2) { // Pellet
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (maze[r][c] === 3) { // Power Pellet
                        ctx.fillStyle = '#FFFF00';
                        ctx.beginPath();
                        ctx.arc(c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPacman() {
            ctx.fillStyle = '#FFFF00'; // Yellow
            ctx.beginPath();
            // Mouth animation
            let angleOffset = 0;
            if (pacman.dx > 0) angleOffset = 0;         // Right
            else if (pacman.dx < 0) angleOffset = Math.PI; // Left
            else if (pacman.dy > 0) angleOffset = Math.PI / 2; // Down
            else if (pacman.dy < 0) angleOffset = -Math.PI / 2; // Up
            
            // If not moving, keep last direction or default
            if(pacman.dx === 0 && pacman.dy === 0 && pacman.lastAngleOffset !== undefined) {
                angleOffset = pacman.lastAngleOffset;
            } else if (pacman.dx !== 0 || pacman.dy !== 0) {
                 pacman.lastAngleOffset = angleOffset;
            }


            pacman.openRate += pacman.openDir * 0.07;
            if (pacman.openRate > Math.PI / 4 || pacman.openRate < 0) {
                pacman.openDir *= -1;
            }
            ctx.arc(pacman.x, pacman.y, pacman.radius, pacman.openRate + angleOffset, -pacman.openRate + angleOffset + Math.PI * 2);
            ctx.lineTo(pacman.x, pacman.y);
            ctx.fill();
        }

        function drawGhosts() {
            ghosts.forEach(ghost => {
                ctx.fillStyle = ghost.isFrightened ? '#ADD8E6' : ghost.color; // Light blue when frightened
                if (ghost.isFrightened && powerPelletTimer < 2000 && Math.floor(powerPelletTimer / 200) % 2 === 0) {
                    ctx.fillStyle = '#FFFFFF'; // Flash white when timer is low
                }

                ctx.beginPath();
                ctx.arc(ghost.x, ghost.y, ghost.radius, Math.PI, 0); // Half circle top
                ctx.lineTo(ghost.x + ghost.radius, ghost.y + ghost.radius); // Bottom right
                // Jagged bottom
                for (let i = 0; i < 3; i++) {
                    ctx.lineTo(ghost.x + ghost.radius - (i * ghost.radius * 2/3) - ghost.radius/3, ghost.y + ghost.radius * 0.7);
                    ctx.lineTo(ghost.x + ghost.radius - ((i+1) * ghost.radius * 2/3), ghost.y + ghost.radius);
                }
                ctx.lineTo(ghost.x - ghost.radius, ghost.y + ghost.radius); // Bottom left
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = 'white';
                const eyeOffsetX = ghost.radius / 3;
                const eyeOffsetY = -ghost.radius / 4;
                ctx.beginPath();
                ctx.arc(ghost.x - eyeOffsetX, ghost.y + eyeOffsetY, ghost.radius / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ghost.x + eyeOffsetX, ghost.y + eyeOffsetY, ghost.radius / 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'black'; // Pupils
                let pupilDx = 0, pupilDy = 0;
                if (ghost.dx > 0) pupilDx = 2; else if (ghost.dx < 0) pupilDx = -2;
                if (ghost.dy > 0) pupilDy = 2; else if (ghost.dy < 0) pupilDy = -2;

                ctx.beginPath();
                ctx.arc(ghost.x - eyeOffsetX + pupilDx, ghost.y + eyeOffsetY + pupilDy, ghost.radius / 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ghost.x + eyeOffsetX + pupilDx, ghost.y + eyeOffsetY + pupilDy, ghost.radius / 6, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function movePacman() {
            const nextGridX = Math.floor((pacman.x + pacman.dx * (pacman.radius + 1) - (pacman.dx < 0 ? TILE_SIZE : 0) ) / TILE_SIZE);
            const nextGridY = Math.floor((pacman.y + pacman.dy * (pacman.radius + 1) - (pacman.dy < 0 ? TILE_SIZE : 0) ) / TILE_SIZE);
            const currentGridX = Math.floor(pacman.x / TILE_SIZE);
            const currentGridY = Math.floor(pacman.y / TILE_SIZE);

            // Tunneling
            if (currentGridX === 0 && pacman.dx < 0 && (currentGridY === 8 || currentGridY === 12)) {
                 pacman.x = (MAZE_COLS -1) * TILE_SIZE + TILE_SIZE/2;
            } else if (currentGridX === MAZE_COLS - 1 && pacman.dx > 0 && (currentGridY === 8 || currentGridY === 12)) {
                 pacman.x = TILE_SIZE/2;
            }


            if (maze[nextGridY] && maze[nextGridY][nextGridX] !== 1) { // Check if next tile is not a wall
                 // Center Pacman in the tile when changing direction or entering a new tile
                if ((pacman.dx !== 0 && pacman.x % TILE_SIZE !== TILE_SIZE / 2) ||
                    (pacman.dy !== 0 && pacman.y % TILE_SIZE !== TILE_SIZE / 2)) {
                    // Snap to center if moving into a new cell
                    if (pacman.dx !== 0) pacman.y = currentGridY * TILE_SIZE + TILE_SIZE / 2;
                    if (pacman.dy !== 0) pacman.x = currentGridX * TILE_SIZE + TILE_SIZE / 2;
                }
                pacman.x += pacman.dx * 2; // Speed
                pacman.y += pacman.dy * 2;
            } else {
                // If moving along an axis and hitting a wall, snap to center of current tile
                if (pacman.dx !== 0) pacman.x = currentGridX * TILE_SIZE + TILE_SIZE / 2;
                if (pacman.dy !== 0) pacman.y = currentGridY * TILE_SIZE + TILE_SIZE / 2;
            }


            // Pellet eating
            const pacmanGridX = Math.floor(pacman.x / TILE_SIZE);
            const pacmanGridY = Math.floor(pacman.y / TILE_SIZE);
            if (maze[pacmanGridY][pacmanGridX] === 2) { // Pellet
                maze[pacmanGridY][pacmanGridX] = 0; // Eat pellet
                score += 10;
                totalPellets--;
                updateInfoDisplays();
            } else if (maze[pacmanGridY][pacmanGridX] === 3) { // Power Pellet
                maze[pacmanGridY][pacmanGridX] = 0;
                score += 50;
                totalPellets--;
                powerPelletTimer = POWER_PELLET_DURATION;
                ghosts.forEach(g => { g.isFrightened = true; /* Reverse direction might be added here */ });
                updateInfoDisplays();
            }
        }
        
        function getPossibleMoves(entityX, entityY) {
            const moves = [];
            const gridX = Math.floor(entityX / TILE_SIZE);
            const gridY = Math.floor(entityY / TILE_SIZE);

            // Check up, down, left, right
            if (maze[gridY-1] && maze[gridY-1][gridX] !== 1) moves.push({dx:0, dy:-1}); // Up
            if (maze[gridY+1] && maze[gridY+1][gridX] !== 1) moves.push({dx:0, dy:1});  // Down
            if (maze[gridY] && maze[gridY][gridX-1] !== 1 && !(gridY === 8 && gridX-1 < 0) && !(gridY === 12 && gridX-1 < 0) ) moves.push({dx:-1, dy:0}); // Left
            if (maze[gridY] && maze[gridY][gridX+1] !== 1 && !(gridY === 8 && gridX+1 >= MAZE_COLS) && !(gridY === 12 && gridX+1 >= MAZE_COLS) ) moves.push({dx:1, dy:0});  // Right
            
            return moves;
        }


        function moveGhosts() {
            ghosts.forEach(ghost => {
                const currentGridX = Math.floor(ghost.x / TILE_SIZE);
                const currentGridY = Math.floor(ghost.y / TILE_SIZE);

                // Only change direction if centered in a tile (at an intersection)
                if (ghost.x % TILE_SIZE === TILE_SIZE / 2 && ghost.y % TILE_SIZE === TILE_SIZE / 2) {
                    let possibleMoves = getPossibleMoves(ghost.x, ghost.y);
                    
                    // Prevent ghost from immediately reversing unless at a dead end
                    possibleMoves = possibleMoves.filter(move => !(move.dx === -ghost.dx && move.dy === -ghost.dy));
                    if (possibleMoves.length === 0) { // If only option is to reverse (dead end)
                         possibleMoves = getPossibleMoves(ghost.x, ghost.y); // Get all moves again including reverse
                    }


                    if (possibleMoves.length > 0) {
                        let bestMove = possibleMoves[0];
                        let minDistance = Infinity;

                        // Target logic
                        let targetX = pacman.x;
                        let targetY = pacman.y;

                        if (ghost.isFrightened) { // Run away
                            targetX = Math.random() * canvas.width; // Random target when frightened
                            targetY = Math.random() * canvas.height;
                        } else {
                            // Simple chase Pacman logic (can be expanded for Blinky, Pinky, etc.)
                            // For now, all ghosts chase Pacman directly
                        }
                        
                        // Choose move that gets closest to target
                        for(const move of possibleMoves) {
                            const nextX = ghost.x + move.dx * TILE_SIZE;
                            const nextY = ghost.y + move.dy * TILE_SIZE;
                            const distance = Math.sqrt(Math.pow(nextX - targetX, 2) + Math.pow(nextY - targetY, 2));
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestMove = move;
                            }
                        }
                        ghost.dx = bestMove.dx;
                        ghost.dy = bestMove.dy;
                    }
                }
                
                // Actual movement (slower than Pacman)
                ghost.x += ghost.dx * 1.5; 
                ghost.y += ghost.dy * 1.5;

                // Tunneling for ghosts
                const ghostGridX = Math.floor(ghost.x / TILE_SIZE);
                const ghostGridY = Math.floor(ghost.y / TILE_SIZE);
                 if (ghostGridX <= 0 && ghost.dx < 0 && (ghostGridY === 8 || ghostGridY === 12)) {
                     ghost.x = (MAZE_COLS -1) * TILE_SIZE + TILE_SIZE/2;
                } else if (ghostGridX >= MAZE_COLS - 1 && ghost.dx > 0 && (ghostGridY === 8 || ghostGridY === 12)) {
                     ghost.x = TILE_SIZE/2;
                }

            });
        }

        function checkCollisions() {
            ghosts.forEach(ghost => {
                const distX = pacman.x - ghost.x;
                const distY = pacman.y - ghost.y;
                const distance = Math.sqrt(distX * distX + distY * distY);

                if (distance < pacman.radius + ghost.radius) {
                    if (ghost.isFrightened) {
                        score += 200; // Score for eating ghost
                        updateInfoDisplays();
                        // Reset this ghost to spawn point (simplified)
                        ghost.x = Math.floor(MAZE_COLS / 2) * TILE_SIZE + TILE_SIZE / 2; // Center spawn
                        ghost.y = 8 * TILE_SIZE + TILE_SIZE / 2; // Ghost box area
                        ghost.isFrightened = false; // No longer frightened
                        ghost.dx = 0; ghost.dy = 0; // Stop it for a moment
                    } else { // Pacman caught
                        lives--;
                        updateInfoDisplays();
                        gameActive = false; // Pause game briefly
                        if (lives > 0) {
                            setTimeout(resetLevel, 1000); // Delay before reset
                        } else {
                            gameOver();
                        }
                    }
                }
            });
        }
        
        function checkWinCondition() {
            if (totalPellets <= 0) {
                gameActive = false;
                showModal("You Win!", `Final Score: ${score}`, "Play Again", fullGameReset);
            }
        }

        function gameLoop() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            movePacman();
            drawPacman();
            moveGhosts();
            drawGhosts();
            checkCollisions();
            checkWinCondition();

            if (powerPelletTimer > 0) {
                powerPelletTimer -= 1000 / 60; // Roughly 60 FPS
                if (powerPelletTimer <= 0) {
                    ghosts.forEach(g => g.isFrightened = false);
                }
            }
            if (gameActive) { // Check again in case collision changed gameActive
                 gameLoopTimeout = requestAnimationFrame(gameLoop);
            }
        }
        
        function showModal(title, text, buttonText, buttonAction) {
            if (gameLoopTimeout) cancelAnimationFrame(gameLoopTimeout);
            gameActive = false;
            modalTitle.textContent = title;
            modalText.textContent = text;
            if (title === "Game Over!" || title === "You Win!") {
                modalScoreInfo.style.display = 'block';
                modalCurrentScore.textContent = score;
            } else {
                modalScoreInfo.style.display = 'none';
            }
            modalButton.textContent = buttonText;
            modalButton.onclick = () => {
                gameModal.style.display = 'none';
                buttonAction();
            };
            gameModal.style.display = 'flex';
        }

        function startGameLoop() {
            gameActive = true;
            if (gameLoopTimeout) cancelAnimationFrame(gameLoopTimeout);
            gameLoop();
        }
        
        function fullGameReset() { // When starting a new game from game over/win
            initializeGameVariables(); // Full reset of score, lives, maze pellets
            // Need to re-draw the maze with pellets if they were eaten
            // For simplicity, we'll assume the maze array is reset or re-initialized if needed.
            // The current maze array is mutated when pellets are eaten.
            // For a true new game, we'd need to deep copy the original maze.
            // For now, let's just re-count pellets for the win condition.
            countPellets(); // Re-count based on current maze state (or ideally reset maze)
            showModal("Get Ready!", "Use arrow keys or swipe.", "Start", startGameLoop);
        }


        function gameOver() {
            gameActive = false;
            showModal("Game Over!", `Final Score: ${score}`, "Play Again", fullGameReset);
        }

        // Keyboard Controls
        document.addEventListener('keydown', (e) => {
            if (!gameActive && gameModal.style.display === 'none') return; // Only process if game active or modal allowing start
            if (gameModal.style.display === 'flex' && e.key !== 'Enter' && e.key !== ' ') return; // Only Enter/Space for modal

            if (gameModal.style.display === 'flex' && (e.key === 'Enter' || e.key === ' ')) {
                modalButton.click(); // Simulate click on modal button
                return;
            }

            let newDx = 0, newDy = 0;
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') newDx = -1;
            else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') newDx = 1;
            else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') newDy = -1;
            else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') newDy = 1;
            else return; // Not an arrow key

            // Check if the new direction is valid before committing
            const tempNextGridX = Math.floor((pacman.x + newDx * TILE_SIZE - (newDx < 0 ? TILE_SIZE : 0) ) / TILE_SIZE);
            const tempNextGridY = Math.floor((pacman.y + newDy * TILE_SIZE - (newDy < 0 ? TILE_SIZE : 0) ) / TILE_SIZE);

            if (maze[tempNextGridY] && maze[tempNextGridY][tempNextGridX] !== 1) {
                pacman.dx = newDx;
                pacman.dy = newDy;
            }
            e.preventDefault();
        });
        
        // Swipe Controls
        let touchStartX = 0, touchStartY = 0;
        canvas.addEventListener('touchstart', (e) => {
            if (!gameActive && gameModal.style.display === 'none') return;
            if (gameModal.style.display === 'flex') return; // Don't handle swipe if modal is up for other reasons
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!gameActive && gameModal.style.display === 'none') return;
            if (gameModal.style.display === 'flex') return;

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            let newDx = 0, newDy = 0;
            if (Math.abs(deltaX) > Math.abs(deltaY)) { // Horizontal swipe
                if (deltaX > 30) newDx = 1; else if (deltaX < -30) newDx = -1;
            } else { // Vertical swipe
                if (deltaY > 30) newDy = 1; else if (deltaY < -30) newDy = -1;
            }

            if (newDx !== 0 || newDy !== 0) {
                const tempNextGridX = Math.floor((pacman.x + newDx * TILE_SIZE - (newDx < 0 ? TILE_SIZE : 0) ) / TILE_SIZE);
                const tempNextGridY = Math.floor((pacman.y + newDy * TILE_SIZE - (newDy < 0 ? TILE_SIZE : 0) ) / TILE_SIZE);
                if (maze[tempNextGridY] && maze[tempNextGridY][tempNextGridX] !== 1) {
                    pacman.dx = newDx;
                    pacman.dy = newDy;
                }
            }
            e.preventDefault();
        }, { passive: false });


        startButton.addEventListener('click', () => {
            if (gameModal.style.display === 'flex') { // If modal is already shown (e.g. from game over)
                modalButton.click();
            } else {
                fullGameReset(); // Start a fresh game
            }
        });
        
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            touchInfoElement.style.display = 'block';
        }

        // Initial Setup
        initializeGameVariables();
        drawMaze(); // Draw initial maze state
        drawPacman(); // Draw Pacman at start
        drawGhosts(); // Draw ghosts at start
        showModal("Get Ready!", "Use arrow keys or swipe to move.", "Start", startGameLoop);

    </script>
</body>
</html>
