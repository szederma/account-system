<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DistanzuinoBT</title>
  <style>
    .slider-container {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
    }
    .slider-wrapper {
      text-align: center;
    }

    .tones-container {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .tone {
      display: inline-block;
      width: 30px;
      height: 30px;
      text-align: center;
      line-height: 30px;
      border: 1px solid black;
      border-radius: 5px;
      background-color: lightgray;
    }

    .tone.active {
      background-color: yellow;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>DistanzuinoBT</h1>

  <div id="top-container">
    <div id="button-container">
      <button id="connect" class="button">Connect</button>
      <button id="disconnect" class="button">Disconnect</button>
    </div>
  </div>

  <div id="card1" class="card">
    <p id="distance1" class="distance-display fade-in">Distance 1: Disconnected</p>
  </div>

  <div id="card2" class="card">
    <p id="distance2" class="distance-display fade-in">Distance 2: Disconnected</p>
  </div>
  
  <div id="instrument-container" class="slider-wrapper">
    <label for="instrument">Choose an instrument:</label>
    <select id="instrument">
      <option value="piano">Piano</option>
      <option value="flute">Flute</option>
    </select>
  </div>

  <div class="slider-container">
    <!-- Volume 1 Slider -->
    <div class="slider-wrapper">
      <label for="volume1">Volume for Distance 1:</label>
      <input type="range" id="volume1" min="0" max="1" step="0.01" value="1">
      <span id="volume1Value">1</span>
      <button id="mute1" class="mute-button">Mute</button> <!-- Mute Button for Distance 1 -->

      <!-- Tones for Distance 1 -->
      <div id="tones1" class="tones-container">
        <div class="tone" data-tone="C1">C1</div>
        <div class="tone" data-tone="D1">D1</div>
        <div class="tone" data-tone="E1">E1</div>
        <div class="tone" data-tone="F1">F1</div>
        <div class="tone" data-tone="G1">G1</div>
        <div class="tone" data-tone="A1">A1</div>
        <div class="tone" data-tone="H1">H1</div>
      </div>
    </div>
    
    <!-- Volume 2 Slider -->
    <div class="slider-wrapper">
      <label for="volume2">Volume for Distance 2:</label>
      <input type="range" id="volume2" min="0" max="1" step="0.01" value="1">
      <span id="volume2Value">1</span>
      <button id="mute2" class="mute-button">Mute</button> <!-- Mute Button for Distance 2 -->

      <!-- Tones for Distance 2 -->
      <div id="tones2" class="tones-container">
        <div class="tone" data-tone="C2">C2</div>
        <div class="tone" data-tone="D2">D2</div>
        <div class="tone" data-tone="E2">E2</div>
        <div class="tone" data-tone="F2">F2</div>
        <div class="tone" data-tone="G2">G2</div>
        <div class="tone" data-tone="A2">A2</div>
        <div class="tone" data-tone="H2">H2</div>
      </div>
    </div>
  </div>

  <script>
    let bluetoothDevice;
    let server;
    let service;
    let characteristic;

    let distance1 = 0;
    let distance2 = 0;

    const HM10_SERVICE_UUID = '0000ffe0-0000-1000-8000-00805f9b34fb';
    const HM10_CHARACTERISTIC_UUID = '0000ffe1-0000-1000-8000-00805f9b34fb';

    document.getElementById('connect').addEventListener('click', async () => {
      try {
        bluetoothDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'DistanzuinoBT' }],
          optionalServices: [HM10_SERVICE_UUID]
        });

        // Add the disconnect event listener
        bluetoothDevice.addEventListener('gattserverdisconnected', () => {
          console.log('Device disconnected unexpectedly.');

          // Stop all active sounds
          stopFrequencies(1);
          stopFrequencies(2);

          // Update UI state
          document.getElementById('connect').style.opacity = '1';
          document.getElementById('connect').style.pointerEvents = 'auto';
          document.getElementById('disconnect').style.opacity = '0';
          document.getElementById('disconnect').style.pointerEvents = 'none';

          updateUIState(false);
        });

        server = await bluetoothDevice.gatt.connect();
        service = await server.getPrimaryService(HM10_SERVICE_UUID);
        characteristic = await service.getCharacteristic(HM10_CHARACTERISTIC_UUID);

        characteristic.startNotifications();
        characteristic.addEventListener('characteristicvaluechanged', handleData);

        document.getElementById('connect').style.opacity = '0';
        document.getElementById('connect').style.pointerEvents = 'none';
        document.getElementById('disconnect').style.opacity = '1';
        document.getElementById('disconnect').style.pointerEvents = 'auto';


        initializeOscillators(1);
        initializeOscillators(2);

        updateUIState(true);
      } catch (error) {
        console.error('Error connecting:', error);
      }
    });


    function handleData(event) {
      const decoder = new TextDecoder();
      const rawValue = decoder.decode(event.target.value).trim();

      // Split data into multiple packets in case they're concatenated
      const packets = rawValue.split('\n'); // Assuming newline '\n' separates packets
      packets.forEach(packet => {
        const value = packet.trim();

        if (value.startsWith('D1:')) {
          const parsedValue = parseFloat(value.substring(3));
          if (!isNaN(parsedValue)) {
            distance1 = parsedValue / 10; // Convert to cm
            updateDistanceDisplay(document.getElementById('distance1'), "1", distance1);
          }
        } else if (value.startsWith('D2:')) {
          const parsedValue = parseFloat(value.substring(3));
          if (!isNaN(parsedValue)) {
            distance2 = parsedValue / 10; // Convert to cm
            updateDistanceDisplay(document.getElementById('distance2'), "2", distance2);
          }
        }
      });

      // Refresh audio with corrected distances
      handleSliderChange();
    }




    function updateDistanceDisplay(distanceElement, distanceLabel, distance) {
      distanceElement.innerText = `Distance ${distanceLabel}: ${distance.toFixed(2)} cm`;
      distanceElement.classList.add('fade-in');
    }

    document.getElementById('disconnect').addEventListener('click', () => {
      if (bluetoothDevice && bluetoothDevice.gatt.connected) {
        bluetoothDevice.gatt.disconnect();
      }

      // Stop all active sounds
      stopFrequencies(1);
      stopFrequencies(2);

      // Clear tone highlights
      highlightTone('tones1', []);
      highlightTone('tones2', []);

      document.getElementById('connect').style.opacity = '1';
      document.getElementById('connect').style.pointerEvents = 'auto';
      document.getElementById('disconnect').style.opacity = '0';
      document.getElementById('disconnect').style.pointerEvents = 'none';

      updateUIState(false);
    });

    function updateUIState(isConnected) {
      if (isConnected) {
        document.getElementById('distance1').innerText = 'Distance 1: Waiting...';
        document.getElementById('distance2').innerText = 'Distance 2: Waiting...';
      } else {
        document.getElementById('distance1').innerText = 'Distance 1: Disconnected';
        document.getElementById('distance2').innerText = 'Distance 2: Disconnected';

        // Stop all frequencies
        stopFrequencies(1);
        stopFrequencies(2);

        // Clear tone highlights
        highlightTone('tones1', []);
        highlightTone('tones2', []);

        distance1 = 0;
        distance2 = 0;
      }
    }







    //*****

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const oscillators = {
      1: [],
      2: []
    };

    const gains = {
      1: [],
      2: []
    };



    function initializeOscillators(label) {
      for (let i = 0; i < 3; i++) { // Create three oscillators for each label
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.value = 0; // Start at 0 Hz (silent)

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        gainNode.gain.value = 0; // Start with no sound
        oscillator.start();

        oscillators[label].push(oscillator);
        gains[label].push(gainNode);
      }
    }

    const frequencyRanges = {
      1: [
        { min: 3, max: 8.99, tone: 'H1', },
        { min: 9, max: 14.99, tone: 'A1', },
        { min: 15, max: 20.99, tone: 'G1' },
        { min: 21, max: 26.99, tone: 'F1' },
        { min: 27, max: 32.99, tone: 'E1' },
        { min: 33, max: 38.99, tone: 'D1' },
        { min: 39, max: 45, tone: 'C1' }
      ],
      2: [
        { min: 3, max: 8.99, tone: 'C2' },
        { min: 9, max: 14.99, tone: 'D2' },
        { min: 15, max: 20.99, tone: 'E2' },
        { min: 21, max: 26.99, tone: 'F2' },
        { min: 27, max: 32.99, tone: 'G2' },
        { min: 33, max: 38.99, tone: 'A2' },
        { min: 39, max: 45, tone: 'H2' }
      ]
    };

    
    const pianoToneMap = {
      'C1': [[133, 0.0045], [258, 0.0041], [391, 0.012]],
      'D1': [[150, 0.04], [291,  0.06], [441, 0.045]],
      'E1': [[166, 0.0175], [333, 0.015], [492, 0.022]],
      'F1': [[175, 0.03], [350, 0.055], [525, 0.045]],
      'G1': [[200, 0.009], [391, 0.086], [591, 0.03]],
      'A1': [[216, 0.059], [441, 0.088], [657, 0.021]],
      'H1': [[250, 0.02], [491, 0.11], [747, 0.02]],
      'C2': [[258, 0.034], [524, 0.028], [782, 0.003]],
      'D2': [[292, 0.0275], [582, 0.009], [883, 0.0015]],
      'E2': [[324, 0.0095], [658, 0.0036], [987, 0.0041]],
      'F2': [[350, 0.038], [692, 0.028], [1040, 0.006]],
      'G2': [[391, 0.096], [782, 0.026], [1174, 0.014]],
      'A2': [[440, 0.0357], [877, 0.012], [1318, 0.007]],
      'H2': [[492, 0.0315], [989, 0.009], [1483, 0.005]]
    };


    const fluteToneMap = {
      'C1': [[527, 0.015], [1087, 0.053], [1649, 0.013]],
      'D1': [[617.33, 0.011], [1208.3, 0.009], [1850.9, 0.003]],
      'E1': [[665.81, 0.03], [1332, 0.017], [1998, 0.016]],
      'F1': [[708.28, 0.06], [1426, 0.01], [2136, 0.01]],
      'G1': [[773.87, 0.047], [1563, 0.005], [2337, 0.003]],
      'A1': [[872.26, 0.08], [1749, 0.0025], [2606, 0.012]],
      'H1': [[980.65, 0.145], [1971, 0.01], [2921, 0.003]],
      'C2': [[1087, 0.07396], [2131, 0.03017], [3272, 0.01365]],
      'D2': [[1152, 0.07838], [3445, 0.04875], [5221, 0.02177]],
      'E2': [[1378, 0.09375], [4734, 0.06698], [6718, 0.02801]],
      'F2': [[1788, 0.12165], [2929, 0.04144], [4522, 0.01885]],
      'G2': [[1637, 0.11138], [4823, 0.06824], [8010, 0.0334]],
      'A2': [[1001, 0.0681], [2003, 0.02834], [3058, 0.01275]],
      'H2': [[1044, 0.07103], [1871, 0.02647], [2821, 0.01176]]
    };


    let currentInstrument = "piano"; // Default is Piano


    function getFrequencies(label, distance) {
      const toneMap = currentInstrument === "piano" ? pianoToneMap : fluteToneMap; // Choose the tone map based on the selected instrument
      const ranges = frequencyRanges[label];
      
      for (const range of ranges) {
        if (distance >= range.min && distance <= range.max) {
          const tone = range.tone; // E.g., 'H1', 'C1'
          const frequenciesWithIntensity = toneMap[tone]; // Get array for this tone, now including intensities
          return frequenciesWithIntensity ? frequenciesWithIntensity : [];
        }
      }
      return [];
    }


    function playFrequencies(frequenciesWithIntensity, volume, label) {
      frequenciesWithIntensity.forEach(([freq, intensity], index) => {
        if (oscillators[label][index]) {
          const oscillator = oscillators[label][index];
          const gainNode = gains[label][index];

          // Smoothly transition frequency and gain
          oscillator.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.01);
          gainNode.gain.setTargetAtTime(volume * intensity, audioCtx.currentTime, 0.01);
        }
      });

      // Turn off unused oscillators
      for (let i = frequenciesWithIntensity.length; i < oscillators[label].length; i++) {
        gains[label][i].gain.setTargetAtTime(0, audioCtx.currentTime, 0.01); // Smooth fade-out
      }
    }


    function stopFrequencies(label) {
      gains[label].forEach(gainNode => {
        gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01); // Smooth fade-out
      });
    }

    document.getElementById('instrument').addEventListener('change', function() {
      currentInstrument = this.value; // Update the current instrument
      handleSliderChange(); // Recalculate and play frequencies with the new instrument
    });



    function highlightTone(tonesContainerId, distance) {
      const tonesContainer = document.getElementById(tonesContainerId);
      const tones = tonesContainer.querySelectorAll('.tone');
      tones.forEach(tone => tone.classList.remove('active'));

      // Find the frequency range based on the distance
      const label = tonesContainerId === 'tones1' ? 1 : 2;
      const ranges = frequencyRanges[label];

      // Find the corresponding tone
      for (const range of ranges) {
        if (distance >= range.min && distance <= range.max) {
          const toneName = range.tone;
          const matchingTone = Array.from(tones).find(tone => tone.textContent === toneName);
          if (matchingTone) {
            matchingTone.classList.add('active');
          }
          break; // Stop searching once the correct tone is found
        }
      }
    }


    let isMuted1 = false;
    let isMuted2 = false;

    // Handle mute button clicks
    document.getElementById('mute1').addEventListener('click', () => {
      isMuted1 = !isMuted1;
      document.getElementById('mute1').textContent = isMuted1 ? 'Unmute' : 'Mute';
      handleSliderChange(); // Update sound state
    });

    document.getElementById('mute2').addEventListener('click', () => {
      isMuted2 = !isMuted2;
      document.getElementById('mute2').textContent = isMuted2 ? 'Unmute' : 'Mute';
      handleSliderChange(); // Update sound state
    });


    function handleSliderChange() {

      const volume1 = isMuted1 ? 0 : parseFloat(document.getElementById("volume1").value);
      const volume2 = isMuted2 ? 0 : parseFloat(document.getElementById("volume2").value);

      const frequencies1 = distance1 >= 3 && distance1 <= 45 ? getFrequencies("1", distance1) : [];
      const frequencies2 = distance2 >= 3 && distance2 <= 45 ? getFrequencies("2", distance2) : [];

      if (frequencies1.length > 0) {
        playFrequencies(frequencies1, volume1, 1);
        highlightTone('tones1', distance1);
      } else {
        stopFrequencies(1);
        highlightTone('tones1', []);
      }

      if (frequencies2.length > 0) {
        playFrequencies(frequencies2, volume2, 2);
        highlightTone('tones2', distance2);
      } else {
        stopFrequencies(2);
        highlightTone('tones2', []);
      }


      document.getElementById("volume1Value").textContent = volume1.toFixed(2);
      document.getElementById("volume2Value").textContent = volume2.toFixed(2);
    }

    document.querySelectorAll('input[type="range"]').forEach(slider => {
      slider.addEventListener("input", handleSliderChange);
    });
  </script>
</body>
</html>
